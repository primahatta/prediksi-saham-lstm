# -*- coding: utf-8 -*-
"""Copy of ACC Berhasil Skripsi Prima 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W9UlgdT0VxGBvd_oqrWvklkCB2Wx-7Yv

## Import Library
"""

# Import Library
import math
import numpy as np #library perhitugan variable
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns #library visualisasi data
import plotly.express as px
import plotly.graph_objects as go

from tensorflow.keras.layers import LSTM, Dropout, Dense, TimeDistributed
from sklearn.metrics import mean_squared_error, mean_absolute_error
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential #library pemodelan deep learning
from keras.layers import Dense, LSTM, Dropout, GRU
from tensorflow.keras.optimizers import SGD
from tensorflow.keras.callbacks import EarlyStopping

import warnings
warnings.filterwarnings('ignore')

"""## Data Preparation"""

import streamlit as st

st.title("Prediksi Harga Saham LSTM")

uploaded_file = st.file_uploader("Upload file CSV dengan kolom 'Date' dan 'Close'")
if uploaded_file is not None:
    df = pd.read_csv(uploaded_file)

    # Proses selanjutnya...
    # df = df.sort_values('Date') dst.

df.shape

# Cek Data Duplikat
df.duplicated().sum()

# Cek Data Kosong
df.isnull().sum()

"""## Data Preprocessing"""

# Urutkan data berdasarkan tanggal (pastikan ada kolom 'Date')
df = df.sort_values('Date')

# Hilangkan baris yang memiliki nilai kosong
df = df.dropna()

# Ambil hanya kolom 'Close' sebagai target prediksi
data = df['Close'].values.reshape(-1, 1)

# Tampilkan 5 nilai teratas dari kolom Close
display(df['Close'].head())

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range=(0, 1))  # skala 0 ke 1
scaled_data = scaler.fit_transform(data)     # ubah data asli jadi skala 0-1

df_scaled_combined = df[['Date']].copy()
df_scaled_combined['Close_Scaled'] = scaled_data

display(df_scaled_combined.head(10))

# Pastikan kolom 'Date' dalam format datetime
df_scaled_combined['Date'] = pd.to_datetime(df_scaled_combined['Date'], format='%Y-%m-%d')

# Tampilkan hasilnya
display(df_scaled_combined.head(10))

# Tampilkan tipe data
print(df_scaled_combined.dtypes)

print(f"Jumlah data setelah normalisasi: {len(scaled_data)}")

# Pastikan panjang data lebih besar dari time_step
if len(scaled_data) > time_step:
    X, y = create_dataset(scaled_data, time_step)
    print(f"Jumlah data X: {len(X)}, Jumlah data y: {len(y)}")
else:
    print(f"Data tidak cukup untuk time_step {time_step}. Data yang ada: {len(scaled_data)}")

import numpy as np

# Fungsi untuk membuat dataset untuk LSTM
def create_dataset(data, time_step):
    X, y = [], []
    for i in range(len(data) - time_step):
        X.append(data[i:(i + time_step), 0])  # Ambil data selama time_step
        y.append(data[i + time_step, 0])      # Target adalah data setelah time_step
    return np.array(X), np.array(y)

# Mengatur time_step (gunakan 20)
time_step = 20

# Membuat dataset untuk LSTM menggunakan data yang sudah dinormalisasi
X, y = create_dataset(scaled_data, time_step)

# Memeriksa dimensi dataset yang dihasilkan
print("Shape of X:", X.shape)
print("Shape of y:", y.shape)

# Melakukan reshape untuk data X menjadi (samples, time_step, features)
X = X.reshape(X.shape[0], X.shape[1], 1)

# Memeriksa ulang dimensi X setelah reshape
print("Shape of X after reshape:", X.shape)

# Pembagian data menjadi training (80%) dan testing (20%)
train_size = int(len(X) * 0.8)  # Hitung ukuran data training (80%)
X_train, X_test = X[:train_size], X[train_size:]  # Ambil 80% data untuk training, sisanya untuk testing
y_train, y_test = y[:train_size], y[train_size:]  # Sama untuk target (y)

import matplotlib.pyplot as plt

# Hitung ukuran data training
train_size = int(len(df_scaled_combined) * 0.8)

# Bagi data menjadi training dan testing
train_data = df_scaled_combined[:train_size]
test_data = df_scaled_combined[train_size:]

# Plot
plt.figure(figsize=(16, 6))
plt.plot(train_data['Date'], train_data['Close_Scaled'], label='Training Data', color='blue')
plt.plot(test_data['Date'], test_data['Close_Scaled'], label='Testing Data', color='orange')
plt.axvline(x=test_data['Date'].iloc[0], color='green', linestyle='--', label='Split Point (80/20)')
plt.title('Visualisasi Pembagian Data Training dan Testing (Terskala)')
plt.xlabel('Tanggal')
plt.ylabel('Harga Saham (Terskala)')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Pastikan pembagian data sudah dilakukan
print(f"Jumlah data X: {len(X)}, Jumlah data y: {len(y)}")
print(f"Jumlah data X_train: {len(X_train)}, Jumlah data X_test: {len(X_test)}")
print(f"Jumlah data y_train: {len(y_train)}, Jumlah data y_test: {len(y_test)}")

assert len(X_train) == len(y_train), "X_train dan y_train harus sama panjang"
assert len(X_test) == len(y_test), "X_test dan y_test harus sama panjang"

import pandas as pd

# Menampilkan salah satu data (misalnya, data pertama) dalam bentuk 2D
X_train_sample = X_train[0].reshape(1, -1)  # Ambil sampel pertama dan ubah bentuknya menjadi 2D (1, 20)

# Mengonversi X_train_sample ke DataFrame agar lebih mudah dibaca
X_train_df = pd.DataFrame(X_train_sample, columns=[f"TimeStep_{i+1}" for i in range(X_train_sample.shape[1])])

# Menampilkan data X_train pertama dalam bentuk tabel
print("data pertama di X_train dalam bentuk tabel:")
print(X_train_df)

"""## Arsitektur Model LSTM"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dropout, Dense

model = Sequential()

# LSTM pertama
model.add(LSTM(units=50, return_sequences=True, input_shape=(time_step, 1)))
model.add(Dropout(0.2))

# LSTM kedua
model.add(LSTM(units=50, return_sequences=False))
model.add(Dropout(0.2))

# Dense intermediate layer
model.add(Dense(units=25, activation='relu'))  # Lebih umum pakai relu di hidden layer

# Output layer
model.add(Dense(units=1))  # Aktivasi default = linear, cocok untuk regresi

# Ringkasan
model.summary()

# Kompilasi model dengan optimizer Adam dan loss function Mean Squared Error
model.compile(optimizer='adam', loss='mean_squared_error')

from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

# Path untuk menyimpan model terbaik
checkpoint_filepath = 'best_model.keras'

# Callback untuk menyimpan model terbaik berdasarkan val_loss
model_checkpoint_callback = ModelCheckpoint(
    filepath=checkpoint_filepath,
    save_weights_only=False,  # Simpan seluruh model, bukan hanya weights
    monitor='val_loss',       # Monitor validation loss
    mode='min',               # Mencari nilai terkecil (karena kita ingin val_loss sekecil mungkin)
    save_best_only=True       # Hanya simpan model terbaik berdasarkan val_loss
)

# Callback untuk menghentikan pelatihan jika tidak ada perbaikan selama 10 epoch
early_stopping = EarlyStopping(
    monitor='val_loss',      # Monitor validation loss
    patience=10,             # Tunggu 10 epoch jika tidak ada perbaikan
    restore_best_weights=True # Kembalikan bobot model terbaik yang ditemukan
)

history = model.fit(
    X_train, y_train,
    epochs=100,  # Jumlah epoch yang diinginkan
    batch_size=16,
    validation_data=(X_test, y_test),  # Data validasi untuk menghitung validation loss
    callbacks=[model_checkpoint_callback, early_stopping]  # Menambahkan callback
)

# Prediksi data pelatihan dan pengujian
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Mengembalikan hasil prediksi ke skala asli
train_predict = scaler.inverse_transform(train_predict)
test_predict = scaler.inverse_transform(test_predict)

# Menampilkan prediksi data uji (hasil prediksi)
print("Nilai Prediksi Data Uji:")
print(test_predict)

# Mengembalikan y_train dan y_test ke skala asli
y_train = scaler.inverse_transform(y_train.reshape(-1, 1))
y_test = scaler.inverse_transform(y_test.reshape(-1, 1))

# Menampilkan data uji yang asli
print("Nilai Aktual Data Uji:")
print(y_test)

# Menampilkan harga aktual dan harga prediksi secara berpasangan
print("Harga Aktual vs Harga Prediksi:")
for actual, pred in zip(y_test.flatten(), test_predict.flatten()):
    print(f"Aktual: {actual:.2f}, Prediksi: {pred:.2f}")

"""## Evaluasi Kinerja Model"""

# Menghitung Root Mean Squared Error (RMSE)
train_rmse = np.sqrt(mean_squared_error(y_train, train_predict))
test_rmse = np.sqrt(mean_squared_error(y_test, test_predict))

# Fungsi untuk menghitung MAPE secara keseluruhan
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

# Menghitung MAPE untuk data pelatihan dan pengujian secara keseluruhan
train_mape = mean_absolute_percentage_error(y_train, train_predict)
test_mape = mean_absolute_percentage_error(y_test, test_predict)

# Mencetak hasil evaluasi
print(f'Train RMSE: {train_rmse}')
print(f'Test RMSE: {test_rmse}')
print(f'Train MAPE: {train_mape:.2f}%')
print(f'Test MAPE: {test_mape:.2f}%')

test_accuracy = 100 - test_mape
print(f'Test Accuracy: {test_accuracy}')

"""## Visualisasi"""

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd

# Reset the index to make 'Date' a column again
df = df.reset_index()

# Ensure the 'Date' column is in datetime format
df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d')  # Adjust format if needed

# Set 'Date' as the index
df.set_index('Date', inplace=True)

plt.figure(figsize=(20, 10))
plt.plot(df.index, df['Close'], label='Harga Sebenarnya', color='blue')  # Adjust column name if needed

plt.xlabel('Tahun')
plt.ylabel('Harga (Rp)')
plt.gca().xaxis.set_major_locator(mdates.YearLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.xticks(rotation=45)
plt.title('Perbandingan Harga Saham BMRI.JK Aktual')
plt.grid(True)
plt.legend()
plt.show()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates

plt.figure(figsize=(20, 10))

# Harga sebenarnya
plt.plot(df.index, df['Close'], label='Harga Sebenarnya', color='blue')

# Prediksi training
plt.plot(df.index[time_step:len(train_predict) + time_step],
         train_predict, label='Prediksi Training', color='orange')

# Prediksi testing
start_index = len(train_predict) + time_step
plt.plot(df.index[start_index:start_index + len(test_predict)],
         test_predict, label='Prediksi Testing', color='green')

# Label sumbu
plt.xlabel('Tahun')
plt.ylabel('Harga Saham BMRI.JK (Rp)')

# Skala y otomatis 10% lebih tinggi dari nilai tertinggi
plt.ylim(0, max(df['Close'].max(), max(train_predict), max(test_predict)) * 1.1)

# Format sumbu x
plt.gca().xaxis.set_major_locator(mdates.YearLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
plt.xticks(rotation=45)

# Judul dan grid
plt.title('Perbandingan Harga Saham BMRI.JK Aktual vs Prediksi')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd
import numpy as np

plt.figure(figsize=(20, 10))

# Membuat DataFrame prediksi agar bisa di-resample dengan tanggal
# Asumsi df.index sudah berupa datetime

# Data aktual mingguan (ambil harga close terakhir tiap minggu)
df_weekly = df['Close'].resample('W').last()

# Prediksi training dan testing kita buat DataFrame juga dengan index tanggal yang sesuai
train_dates = df.index[time_step:len(train_predict) + time_step]
test_dates = df.index[len(train_predict) + time_step : len(train_predict) + time_step + len(test_predict)]

train_pred_df = pd.DataFrame(train_predict.flatten(), index=train_dates, columns=['Prediksi'])
test_pred_df = pd.DataFrame(test_predict.flatten(), index=test_dates, columns=['Prediksi'])

# Resample prediksi per minggu dengan ambil nilai terakhir di minggu tersebut
train_pred_weekly = train_pred_df.resample('W').last()
test_pred_weekly = test_pred_df.resample('W').last()

# Gabung prediksi training dan testing untuk plot mudah
pred_weekly = pd.concat([train_pred_weekly, test_pred_weekly])

# Plot actual dan prediksi mingguan
plt.plot(df_weekly.index, df_weekly, label='Harga Aktual Mingguan', color='blue')
plt.plot(pred_weekly.index, pred_weekly['Prediksi'], label='Prediksi Mingguan', color='orange')

# Label sumbu
plt.xlabel('Tanggal (Mingguan)')
plt.ylabel('Harga Saham BMRI.JK (Rp)')

# Skala y, 10% lebih tinggi dari nilai tertinggi
max_y = max(df_weekly.max(), pred_weekly['Prediksi'].max())
plt.ylim(0, max_y * 1.1)

# Format tanggal di sumbu x untuk mingguan
plt.gca().xaxis.set_major_locator(mdates.MonthLocator())
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

plt.xticks(rotation=45)

# Judul dan grid
plt.title('Perbandingan Harga Saham BMRI.JK Aktual vs Prediksi (Mingguan)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd
import numpy as np

# input tanggal
tanggal_awal = '2019-05-10'
tanggal_akhir = '2019-06-15'

# Pastikan index df datetime
df.index = pd.to_datetime(df.index)

# Filter data aktual sesuai rentang tanggal input user
df_filtered = df.loc[tanggal_awal:tanggal_akhir]

# Ambil tanggal prediksi train dan test
train_dates = df.index[time_step:len(train_predict) + time_step]
test_dates = df.index[len(train_predict) + time_step : len(train_predict) + time_step + len(test_predict)]

train_pred_df = pd.DataFrame(train_predict.flatten(), index=train_dates, columns=['Prediksi'])
test_pred_df = pd.DataFrame(test_predict.flatten(), index=test_dates, columns=['Prediksi'])

# Gabungkan prediksi train + test
pred_df = pd.concat([train_pred_df, test_pred_df])

# Filter prediksi sesuai tanggal input user
pred_filtered = pred_df.loc[tanggal_awal:tanggal_akhir]

# Plot
plt.figure(figsize=(15, 7))
plt.plot(df_filtered.index, df_filtered['Close'], label='Harga Aktual', color='blue')
plt.plot(pred_filtered.index, pred_filtered['Prediksi'], label='Prediksi', color='red')

plt.xlabel('Tanggal')
plt.ylabel('Harga (Rp)')
plt.title(f'Prediksi vs Harga Aktual ({tanggal_awal} s/d {tanggal_akhir})')

plt.xticks(rotation=45)

plt.gca().xaxis.set_major_locator(mdates.DayLocator(interval=1))  # setiap hari
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))

plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Output harga aktual dan prediksi untuk tanggal awal
tanggal_awal_dt = pd.to_datetime(tanggal_awal)

if tanggal_awal_dt in df_filtered.index and tanggal_awal_dt in pred_filtered.index:
    harga_aktual_awal = df_filtered.loc[tanggal_awal_dt, 'Close']
    harga_pred_awal = pred_filtered.loc[tanggal_awal_dt, 'Prediksi']
    print(f"Harga aktual pada {tanggal_awal}: Rp{harga_aktual_awal:.0f}")
    print(f"Harga prediksi pada {tanggal_awal}: Rp{harga_pred_awal:.0f}")
else:
    print(f"Tanggal {tanggal_awal} tidak ada pada data aktual atau prediksi.")

from IPython.display import display

# Gabungkan tanggal, harga aktual, dan prediksi
hasil_perbandingan = pd.DataFrame({
    'Tanggal': df_filtered.index.strftime('%Y-%m-%d'),
    'Harga Aktual': df_filtered['Close'].values,
    'Harga Prediksi': pred_filtered['Prediksi'].reindex(df_filtered.index).values
})

# Tampilkan seperti tabel interaktif
print("\nPerbandingan Harga Aktual dan Prediksi:")
display(hasil_perbandingan)

# Tambahkan kolom selisih dan persentase selisih ke hasil_perbandingan
hasil_perbandingan['Selisih (Rp)'] = abs(hasil_perbandingan['Harga Aktual'] - hasil_perbandingan['Harga Prediksi'])
hasil_perbandingan['Selisih (%)'] = (hasil_perbandingan['Selisih (Rp)'] / hasil_perbandingan['Harga Aktual']) * 100

# Tampilkan hasil lengkap
from IPython.display import display

# Tampilkan tabel rapi
print("\nSelisih Perbandingan Harga Aktual dan Prediksi:")
display(hasil_perbandingan.style.format({
    'Harga Aktual': 'Rp{:.2f}',
    'Harga Prediksi': 'Rp{:.2f}',
    'Selisih (Rp)': 'Rp{:.2f}',
    'Selisih (%)': '{:.2f} %'
}))

from datetime import timedelta
from IPython.display import display  # Hanya berguna jika kamu pakai Jupyter/Colab

future_days = 20  # Jumlah hari ke depan yang ingin diprediksi
last_data = df['Close'][-time_step:].values  # Ambil data penutup terakhir sebanyak time_step
last_data_scaled = scaler.transform(last_data.reshape(-1, 1))  # Scaling

future_predictions = []
input_seq = last_data_scaled.copy()

for _ in range(future_days):
    X_input = np.array(input_seq[-time_step:]).reshape(1, time_step, 1)
    pred_scaled = model.predict(X_input, verbose=0)

    # Simpan prediksi (nanti kita inverse transform)
    future_predictions.append(pred_scaled[0][0])

    # Tambahkan prediksi ke input sequence untuk prediksi berikutnya
    input_seq = np.append(input_seq, pred_scaled[0][0])

# Invers transform hasil prediksi
future_predictions = scaler.inverse_transform(np.array(future_predictions).reshape(-1, 1))

# Buat tanggal masa depan dan konversi ke date (hilangkan waktu)
last_date = df.index[-1]
future_dates = [(last_date + timedelta(days=i+1)).date() for i in range(future_days)]

hasil_future = pd.DataFrame({
    'Tanggal': future_dates,
    'Prediksi Harga Saham (Rp)': future_predictions.flatten()
})

# Tampilkan hasil rapi (pakai display kalau di Jupyter/Colab)
print("\nPrediksi Harga Saham 20 Hari ke Depan:")
display(hasil_future.style.format({'Prediksi Harga Saham (Rp)': 'Rp{:.2f}'}))

# Simpan ke Excel jika perlu (opsional):
# hasil_future.to_excel("prediksi_20_hari_ke_depan.xlsx", index=False)

model.save('model.h5')

